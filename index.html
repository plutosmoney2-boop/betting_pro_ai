// server.js
// УСТАНОВКА: npm init -y
// затем: npm install express node-fetch cors dotenv
// ЗАПУСК: node server.js

import express from 'express';
import cors from 'cors';
import fetch from 'node-fetch';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

// ВАЖНО: ключ НЕ храним в фронте
const API_FOOTBALL_KEY = process.env.API_FOOTBALL_KEY || '21761a0d5aeb99ae7b4edf2cae22f00b';
const API_BASE = 'https://v3.football.api-sports.io';

// ===== 1) МАТЧИ ПО ДАТЕ =====
// GET /api/matches?date=YYYY-MM-DD
app.get('/api/matches', async (req, res) => {
  try {
    const { date } = req.query;
    if (!date) {
      return res.status(400).json({ error: 'date is required (YYYY-MM-DD)' });
    }

    // Берём все матчи на дату
    // https://api-sports.io/documentation/football/v3#operation/get-fixtures[web:11][web:22]
    const url = `${API_BASE}/fixtures?date=${encodeURIComponent(date)}`;
    const apiRes = await fetch(url, {
      headers: {
        'x-apisports-key': API_FOOTBALL_KEY
      }
    });

    if (!apiRes.ok) {
      return res.status(500).json({ error: 'Failed to load fixtures from API' });
    }

    const data = await apiRes.json();
    const fixtures = data.response || [];

    // Группируем: страна → лига → массив матчей
    const grouped = {};

    fixtures.forEach(f => {
      const country = f.league?.country || 'Unknown';
      const leagueName = f.league?.name || 'Unknown league';
      const fixtureId = f.fixture?.id;
      const home = f.teams?.home?.name || 'Home';
      const away = f.teams?.away?.name || 'Away';

      if (!fixtureId) return;

      if (!grouped[country]) grouped[country] = {};
      if (!grouped[country][leagueName]) grouped[country][leagueName] = [];

      grouped[country][leagueName].push({
        id: fixtureId,
        home,
        away
      });
    });

    return res.json(grouped);
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// ===== 2) ПРОВЕРКА, ЧТО МАТЧ ЕСТЬ НА ЭТУ ДАТУ =====
async function checkFixtureOnDate(date, fixtureId) {
  const url = `${API_BASE}/fixtures?id=${fixtureId}`;
  const apiRes = await fetch(url, {
    headers: {
      'x-apisports-key': API_FOOTBALL_KEY
    }
  });

  if (!apiRes.ok) return false;

  const data = await apiRes.json();
  const fixture = data.response?.[0];
  if (!fixture) return false;

  const fixtureDate = fixture.fixture?.date?.slice(0, 10); // YYYY-MM-DD
  return fixtureDate === date;
}

// ===== 3) ПОЛУЧЕНИЕ ПРЕДИКШЕНА ИЗ ОТКРЫТЫХ ИСТОЧНИКОВ =====

// УПРОЩЁННЫЙ ВАРИАНТ: используем predictions endpoint API‑Football,
// который сам строит прогноз по матчу (это тоже «открытый источник»).[web:23]
async function getPredictionParagraph(fixtureId, homeTeam, awayTeam) {
  // https://www.api-football.com/news/post/predictions-endpoint[web:23]
  const url = `${API_BASE}/predictions?fixture=${fixtureId}`;
  const apiRes = await fetch(url, {
    headers: {
      'x-apisports-key': API_FOOTBALL_KEY
    }
  });

  if (!apiRes.ok) {
    return `Не удалось автоматически получить аналитический прогноз по матчу ${homeTeam} — ${awayTeam}. Рекомендуется дополнительно проверить линию и статистику команд перед ставкой.`;
  }

  const data = await apiRes.json();
  const pred = data.response?.[0];

  if (!pred) {
    return `Сервисы с прогнозами не дали однозначного анализа по матчу ${homeTeam} — ${awayTeam}. Команды выглядят примерно равными, поэтому стоит внимательно оценить форму и состав перед выбором исхода.`;
  }

  const winner = pred.winner?.name || 'ни одна из сторон';
  const advice = pred.advice || '';
  const percentHome = pred.predictions?.percent?.home || null;
  const percentDraw = pred.predictions?.percent?.draw || null;
  const percentAway = pred.predictions?.percent?.away || null;

  // Строим короткий абзац (НЕ копируем текст API, только свои формулировки)
  let parts = [];

  parts.push(`Аналитика открытых сервисов указывает, что более вероятный исход — результат в пользу команды ${winner}, хотя гарантии нет.`);

  if (percentHome && percentAway && percentDraw) {
    parts.push(
      `Вероятности приблизительно распределяются так: победа хозяев рассматривается как более перспективная, ничья имеет средний шанс, а успех гостей оценивается чуть ниже.`
    );
  }

  if (advice) {
    parts.push(
      `Обобщая доступные прогнозы, наиболее осторожной стратегией выглядит ставка в пользу более сильной по текущей форме стороны либо выбор рынка с подстраховкой, например двойного исхода или аккуратных тоталов.`
    );
  }

  if (parts.length === 0) {
    parts.push(
      `По этому матчу нет единого консенсуса у открытых аналитических ресурсов, поэтому рекомендуется учитывать персональные модели, лайв‑форму и новости по составам.`
    );
  }

  return parts.join(' ');
}

// POST /api/prediction
app.post('/api/prediction', async (req, res) => {
  try {
    const { date, matchId, homeTeam, awayTeam } = req.body || {};

    if (!date || !matchId || !homeTeam || !awayTeam) {
      return res.status(400).json({ error: 'date, matchId, homeTeam, awayTeam are required' });
    }

    const existsOnDate = await checkFixtureOnDate(date, matchId);
    if (!existsOnDate) {
      return res.status(404).json({ message: 'Матч не найден на эту дату' });
    }

    const paragraph = await getPredictionParagraph(matchId, homeTeam, awayTeam);

    return res.json({ paragraph });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// ===== СТАТИКА С ТВОИМ HTML (по желанию) =====
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Положи твой HTML в файл public/index.html
app.use(express.static(path.join(__dirname, 'public')));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Grandbetting_ai backend running on port ${PORT}`);
});
